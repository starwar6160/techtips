2018-06-21 16:56 antd代码里面login步骤：
service/api.js里面的fakeAccountLogin函数内部是实际执行login动作的地方；收到的数据是fakeAccountLogin {userName: "admin", password: "888888", type: "account"}，我估计这个Demo里面就直接返回成功了， 实际程序要去后台REST API执行认证过程；
model/login.js里面的effects小节内部异步调用了fakeAccountLogin，并作出相应处理；

2018-06-22 11:28 HTML代码注释方法：
<!--注释文字 -->

2018-06-26 11:14 我改了账户密码登录antd，给我说错误，同时明确指出账户密码是admin/888888（这当然是调试期间的临时措施了），我搜索了源码，在.roadhogrc.mock.js里面有这个账户和密码的比较代码。
也就是说，调试用的后端REST API，都是如此Mock模拟的。
'POST /api/login/account': (req, res) => 这一行后面是一个函数体，把账号的几种情况都包括了。真实系统当然是该去数据库查找认证信息，或者使用各种认证服务；
这个代码，实际上是一个叫proxy的数组，内部的键值对，键是各种‘GET /api/users’之类的URL，值是各种反馈数据：
直接的JSON字面量；
某个函数名，定义在别处，内部返回JSON数据;
某个函数体，内部直接写了返回值条件判断逻辑，例如登录；
别的REST API，这个用法比较高级；
这些mock是如何被使用的？看一看；

2018-06-26 13:07 antd底层自带mock工具roadhog，该工具自带代理请求功能；

2018-06-26 17:07 andt的login流程：
login.js:从表单获取的payload用yield异步方法调用fakeAccountLogin，返回的response发出一个changeLoginStatus的消息到redux的存储里面，如果登录成功则reloadAuthorized设置认证成功信息，然后redux导航到根页面；
知识点：effects,yield put,redux,routerRedux
put 用于触发 action:
yield put({ type: 'todos/add', payload: 'Learn Dva' });
call 用于调用异步逻辑，支持 promise:
const result = yield call(fetch, '/todos');
select 用于从 state 里获取数据:
const todos = yield select(state => state.todos);
reloadAuthorized的实质是如下，估计要到redux里面查看该项目；
localStorage.getItem('antd-pro-authority') || 'admin';
解释：src/utils/authority.js
antd pro的权限存在localStorage的key为'antd-pro-authority'。getAuthority这个方法就是获取权限。默认如果没有权限获取的就是'admin'。不知道你们问的是不是这个。。

2018-06-28 13:39
在 Ant Design Pro 中，一个完整的前端 UI 交互到服务端处理流程是这样的：
UI 组件交互操作；
调用 model 的 effect；
调用统一管理的 service 请求函数；
使用封装的 request.js 发送请求；
获取服务端返回；
然后调用 reducer 改变 state；
更新 model。

2018-06-28 14:59 我添加自己的mock数据成功了。需要的步骤：
在.roadhogrc.mock.js文件的proxy数组内部如下写法：
'GET /api/fake627': {
  $body:{
	sum503:6280,
  }
},
注意，第一行是API路径，花括号内部是制定返回内容，暂时只确定这个写法有效，最里层是json数据本身，可以写任何的json数据。最后一行花括号后面跟着的逗号是proxy数组内部各个项目之间的分隔符；
这个测试只是返回一个写死的数据，实际上根据其他数据项目，还可以把API的应答写成一个函数，那么基本上可以把简单的后端模拟逻辑都写在这个mock文件里面了。具体怎么做还有待于试验；
这个mock，我用postman测试URL：http://localhost:8000/api/fake627 也可以获得正确返回值；
但是开始的时候无论是网页还是postman都无法获得正确返回值而是返回页面看上去是空白的HTML，以及修改了mock文件里面的内容，postman返回的内容都不变的怪异现象。我把npm start启动的调试服务器终止后重新启动，提示我8000端口已经被pid为多少的npm进程占用，是否要启动另一个端口。于是我把该PID的进程kill以后，postman获得的mock的数据终于恢复了正常。
所以这个mock问题，起因在于某些我不知道机制细节的原因导致的老的npm调试进程的mock工作不正常，而我的RMBP又没事从不重启，结果就这样了。

2018-06-30 21:26 前端开发调研结果。简单说，不算难但是所需学习知识量太大，我们的人无法在几个月的短时间内熟练掌握。
*	前端开发概念：Web开发中直接呈现给用户看到的部分称之为前端开发，而具体的业务逻辑，数据库等称之为后端开发；
*	前端开发现状：
	*	目前前端开发处于移动互联网广泛发展背景下的技术新兴期，技术蓬勃发展，百花齐放，各种新的开发技术层出不穷，变化很快，所以需要学习的知识很庞杂，但是一般难度都不太高；
	*	学习曲线方面平滑：起步很容易，完全不懂软件开发的人也能很容易的入门，做一些漂亮的网页和特效，很容易收获成就感。因此自学入门的人很多，网上前端生态也因此特别繁荣。
	*	技术进步过程漫长：前端开发所需要掌握的技术知识范围非常广泛，每一门知识里面具体的知识点都特别多而琐碎，而且因为技术新兴时期，很多技术不成熟，坑很多，所以任何一个知识点里面遇到坑的话都需要花费大量时间来解决。
	*	参考Web前端开发的培训班的课程安排，比如达内培训（纳斯达克上市公司，课程设置还是科学合理的）的课程，各个阶段的授课工作日加起来118个工作日，是24个工作周差2天，几乎是半年时间。这个半年时间的培训下来，只是入门水准，只能做一些比较简单的应用，真正要做熟练，达到商业产品级别的产出，没有2，3年时间下不来。
	*	由于各大互联网公司对于前端工程师的高需求，所以目前前端工程师的职业前景正处于全盛时期，职位溢价比较高，2-3年经验的水平还可以的前端工程师至少月薪20K起步，3-5年的水平高的比这个翻倍也不在少数。这个情况类似前些年iOS/Android开发刚兴起的时候的情形；此外一般前端工程师不太愿意到传统行业工作；
*	前端开发技术含量不高，主要也就是以下3方面：
	*	解决浏览器兼容性问题。一个好的前端开发工程师，起码有1/3的时间是无奈的浪费在解决各种浏览器之间的兼容性问题，特别是老旧的IE6，以及各种移动端浏览器和设备的兼容性问题。大量的时间花费在研究各种浏览器的BUG导致的兼容性问题，使用各种“黑科技”来解决兼容性问题，所以用于提高技术的机会就不多了。
	*	解决开发效率问题，包括可维护性，可复用性。层出不穷的各种开发框架例如jQuery,vue,Angular,React,ExtJS，各种包管理工具例如npm,yarn等都是为了解决这些问题的，所以学习负担也很重。
	*	解决性能问题，包括渲染性能，加载性能，内存泄漏等问题。这些都是前端特有问题。
	*	由于前端天生的代码无法加密，容易暴露业务逻辑的特点，所以核心业务逻辑不会放在前端，所以前端开发天生与最有商业价值的核心业务逻辑绝缘；
*	我们的人自己做前端开发的问题：
	*	IT行业的不同大方向之间差异堪比转行，知识共用部分比较少，只有基础知识能共用，大部分具体应用知识需要重新学习，例如做桌面应用开发/游戏开发/嵌入式开发/移动开发/前端开发/数据库开发之间就是差异很大，基本需要重新学习的。基础好可以明显降低重新学习的难度，但是无法大幅降低重新学习所需的时间；
	*	因此如果是自身技术团队技能方向以外的开发需求，就要考虑是培养技术团队还是招人抑或是外包，适用于不同场合。例如较为远期的需求，可以提前开始培养技术团队，比较急的需求而且后续还会大量用到，那么招人合适（然而也要考虑招人难度），比较急但是后续用到的机会不多的情形，就比较适合外包。
	*	我们的人的知识背景主要是基于桌面应用开发，对于前端开发没有基础。经过前面大数据云平台的项目，由于学习曲线的缘故，也只是能维护代码，但是距离从零开始开发还有不少距离。
	*	前端开发对于专业做这个的外包公司来说是熟悉的套路，技术上来说比较简单，技术风险小，开发工期比较有保证。只是业务规则方面需要我们的人与其现场对接，此外设计好架构，前后端分离能明显降低业务对接的难度；
*	前端知识图谱，以下网页简单列出来了前端开发所需的知识图谱。都只列举了最著名的几个主流技术。
    <https://www.processon.com/view/link/5858fa8fe4b0db9f2e0f548e>
    <https://github.com/JacksonTian/fks>
 	<http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.html>
    <https://blog.csdn.net/lucky_lxg/article/details/54583539>
	*	基本技术：HTML5,CSS3,JavaScript
	*	开发调试工具：Visual Studio Code，FireBug，Fiddler，WireShark，ChromeDevTools
	*	标准和规范：DOM，BOM，XHTML，XML，JSON，ECMAScript5/6
	*	自动化构建和测试：jasmine,gulp
	*	数据模拟：roadhogrc
	*	包管理和部署：npm,yarn,webpack,babel,jslint,csslint
	*	js框架：很多，这里只列出来最流行的几个：d3.js,EChart,ExtJS,vue,Angular,React
	*	浏览器兼容性：IE6/7/8/9/10/11，Edge，Chrome，Firefox,Opera,Safari，各种移动浏览器

	2018-07-06 09:51
	技术选型：以上技术选型是沿用已有系统的技术，希望便于运维；
	前端框架采用React/ReactNative；
	后端采用Django/PostgreSQL;
	前后端分离，后端通过REST API提供服务给前端；
	可能需要安卓和IOS客户端，采用ReactNative实现；
	操作系统采用Ubuntu 16.04LTS；
	部署在公有云或者用户自己机器上；
	每个组件都便于部署和迁移，方便分别部署或者集中部署，以及承载更大数据量。
	功能目标：
	业务功能：作为一个售电系统，业务方面具有以下功能模块：客户管理，合同管理，购售电交易，结算管理。具体功能还在写文档；
	技术功能：电力系统的软件总体技术特征是：对于系统可用性，数据持久性，完整性，保密性等安全方面要求很高，性能和并发要求不算高。其中完整性和保密性必须我们自己实现，所以有了以下技术要求：
	用户管理：
	认证：用户名密码认证，短信认证等常见认证措施；
	鉴权：具有权限管理功能，可以区分不同权限等级的用户；
	日志：具有应用级日志，明确而详细的记录谁在何时做了何种操作，并采用密码学HASH和数字签名技术保证日志不可篡改；
	监控报警：具有监控系统主要健康状况指标功能，并能在异常发生时及时通过短信等各种方式报警给管理员的功能；
	数据管理：
	备份：具有每天定时自动备份数据的功能，并能在需要时通过简单执行脚本恢复数据。
	完整性：备份的数据使用HASH算法保证完整性；
	交易不可抵赖性（HASH和数字签名）
	电力传感器数据完整性，保密性（HASH和加密）
	伸缩性：能在必要时可以实现公有云上根据负载自动伸缩规模；
	合同可以线下签字确认具有法律效力，因为电子合同比较麻烦。其他部分，技术上能确认用密码学技术加强安全即可，不追求法律效力。
